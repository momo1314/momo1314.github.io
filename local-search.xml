<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cmake基础知识分享</title>
    <link href="/2022/06/21/Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/"/>
    <url>/2022/06/21/Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一-简单介绍"><a href="#一-简单介绍" class="headerlink" title="一. 简单介绍"></a>一. 简单介绍</h2><p>​CMake是一个跨平台的编译工具，可以用简单的语句来描述所有平台的编译过程。他能够输出各种各样的makefile或者project文件，所有的语句都写在一个叫CMakeLists.txt的文件中。</p><h2 id="二-基本用法"><a href="#二-基本用法" class="headerlink" title="二. 基本用法"></a>二. 基本用法</h2><p>​CMake使用名称为CMakeLists.txt的文件，其中定义了编译和依赖处理等过程。对于一个基本的项目而言，从一个源码文件构建一个可执行程序只需要在CMakeLists.txt文件中添加两行代码即可。</p><p>​文件内容像下面这样：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.6</span>)<br><span class="hljs-keyword">project</span> (CMakeTest)<br><span class="hljs-keyword">add_executable</span> (<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)<br></code></pre></td></tr></table></figure><p>​文件的第一行定义了所需的CMake版本的最小值，这一行是强制添加在CMakeLists.txt文件中，其拥有指定了从第二行开始可以使用的给定版本所定义的cmake函数；</p><p>​第二行的project函数用于定义工程名(这里为CMakeTest)，这个名字被保存在一个名为PROJECT_NAME的变量中；</p><p>​最后一行，在main.cpp文件中创建一个可执行命令(add_executable())，它的名字和工程名称(${PROJECT_NAME})相同，然后将源代码编译到名称为CMakeTest的可执行文件中，也就是将可执行文件名设置为与工程名相同。</p><p>​其中的${}表达式允许访问环境中定义的任何变量，因此，我们可以使用${PROJECT_NAME}变量作为一个可执行程序的输出名。假设这里的main.cpp文件是一个简单的Hello World程序，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Hello World! &quot;</span> &lt;&lt; argc &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​将这两个文件放置在同一目录下，然后依次执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake .<br>make<br></code></pre></td></tr></table></figure><p>​这样，我们就可以在当前目录下面看到一个名称为CMakeTest的可执行文件了。</p><h2 id="三-创建库文件-Creating-a-library"><a href="#三-创建库文件-Creating-a-library" class="headerlink" title="三. 创建库文件(Creating a library)"></a>三. 创建库文件(Creating a library)</h2><p>​CMake允许你创建库文件，可以被OpenCV编译系统使用。软件开发过程中，在多个应用之间共享代码是一种通用并且实用的实践。在大型应用中，或者是当相同的代码在多个应用中共享时，这种使用方式非常有用。</p><p>　　在这种情况下，我们不需要创建一个二进制可执行文件；取而代之，我们创建一个编译好的文件，其中包含了所有的函数、类等等，使用它来开发。我们可以将这个库文件与其它应用共享，而不需要共享我们的源代码。CMake中包含了一个add_library()函数来实现此目的：</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># Create our hello library</span><br><span class="hljs-keyword">add_library</span>(Hello hello.cpp hello.h)<br><span class="hljs-comment"># Create our application that uses our new library</span><br><span class="hljs-keyword">add_executable</span>(executable main.cpp)<br><span class="hljs-comment"># Link our executable with the new library</span><br><span class="hljs-keyword">target_link_libraries</span>(executable Hello)<br></code></pre></td></tr></table></figure><p>​其中以“＃”开头的行为注释行，这些行会被CMake忽略掉。</p><p>　　命令add_library(Hello hello.cpp hello.h)定义了我们新创建的库的名称，库名称为Hello，而hello.cpp和hello.h是库的源文件。我们添加头文件以允许IDE链接到这些头文件。执行这一行命令将会产生一个共享文件（在OS X或者Unix下生成一个*.so文件，在Windows下生成*.dll文件），这取决于我们所使用的操作系统，或者是要创建动态库还是静态库。</p><p>　　target_link_libraries(executable Hello)用于链接我们的可执行文件executable到目标库，在这里，将会链接到Hello库中。</p><p>　　假设我们在hello.cpp中定义一个say()函数用于输出字符串，在hello.h文件中添加此函数的声明：</p><p>​# hello.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __HELLO_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HELLO_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">(std::string text)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>​# hello.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">(std::string text)</span> </span>&#123;<br>std::cout &lt;&lt; text &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　然后，我们在main.cpp中添加hello.h头文件声明，然后引用hello库中定义的say()函数，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;I can say Hello!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​最后，依次执行“cmake .”和“make”命令，就可以看到库链接后生成的可执行文件了。</p><h2 id="四-添加版本号和配置头文件"><a href="#四-添加版本号和配置头文件" class="headerlink" title="四. 添加版本号和配置头文件"></a>四. 添加版本号和配置头文件</h2><p>​第一个要添加的特性就是给我们的可执行文件和项目提供一个版本号。你可以在你的源码之外做到这一点，在 CMakeLists.txt 文件中做这些会更加灵活。为了添加一个版本号我们修改我们的 CMakeList.txt 文件如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.6</span>)<br><span class="hljs-keyword">project</span> (Tutorial)<br><span class="hljs-comment"># The version number.</span><br><span class="hljs-keyword">set</span> (Tutorial_VERSION_MAJOR <span class="hljs-number">1</span>)<br><span class="hljs-keyword">set</span> (Tutorial_VERSION_MINOR <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="五-寻找动态库或静态库-find-library"><a href="#五-寻找动态库或静态库-find-library" class="headerlink" title="五.寻找动态库或静态库(find_library )"></a>五.寻找动态库或静态库(find_library )</h2><ol><li><p>寻找系统库，比如：寻找 log库</p><p>find_library( log-lib log )</p></li><li><p>指定路径寻找库，比如：在当前目录下寻找*<em><strong><a href="http://libmylib.so/">libmylib.so</a></strong></em>*动态库。</p><p>find_library(my_lib libmylib.so .&#x2F;)</p></li></ol><h2 id="六-设置属性-set-target-properties"><a href="#六-设置属性-set-target-properties" class="headerlink" title="六. 设置属性(set_target_properties)"></a>六. 设置属性(set_target_properties)</h2><p>​set_target_properties（…）是一个便捷功能，因为它允许设置多个目标的多个属性。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(a ...)<br><span class="hljs-keyword">add_executable</span>(b ...)<br><span class="hljs-keyword">set_target_properties</span>(<br>a <br>b <br>属性<br>LINKER_LANGUAGE CXX <br>文件夹<span class="hljs-string">&quot;可执行文件&quot;</span> <br>)<br><br><span class="hljs-keyword">set_target_properties</span>(<span class="hljs-keyword">test</span> PROPERTIES LINKER_LANGUAGE CXX) // 指定C++ <br><span class="hljs-keyword">set_target_properties</span>(<span class="hljs-keyword">test</span> PROPERTIES LINKER_LANGUAGE C) // 指定C<br></code></pre></td></tr></table></figure><h2 id="七-追加属性-set-property"><a href="#七-追加属性-set-property" class="headerlink" title="七. 追加属性(set_property)"></a>七. 追加属性(set_property)</h2><p>​<strong>set_property(TARGET …) 可以 APPEND 到列表，或 APPEND_STRING 到目标的基于字符串的属性。</strong></p><p>例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(a ...)<br><span class="hljs-keyword">set_property</span>(<br>目标<br>追加属性<br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span><span class="hljs-string">&quot; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span> <br>)<br><br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <br>APPEND_STRING <br>PROPERTY LINK_FLAGS <span class="hljs-string">&quot; -Wl,--version-script=$&#123;VERSION_SCRIPT&#125;&quot;</span><br>)<br></code></pre></td></tr></table></figure><h2 id="八-CMake-string-REPLACE"><a href="#八-CMake-string-REPLACE" class="headerlink" title="八. CMake string REPLACE"></a>八. CMake string REPLACE</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>) <br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>) <br><span class="hljs-keyword">set</span>(in <span class="hljs-string">&quot;ONEFLOW::test&quot;</span>) <br><span class="hljs-keyword">message</span>( STATUS <span class="hljs-string">&quot;in = $&#123;in&#125;&quot;</span> ) <br><span class="hljs-keyword">string</span>(REPLACE <span class="hljs-string">&quot;::&quot;</span> <span class="hljs-string">&quot;_&quot;</span> out <span class="hljs-string">&quot;$&#123;in&#125;&quot;</span>) <br><span class="hljs-keyword">message</span>( STATUS <span class="hljs-string">&quot;out = $&#123;out&#125;&quot;</span> )<br></code></pre></td></tr></table></figure><p>target_link_libraries</p><p>结果：</p><img src="/2022/06/21/Cmake%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%88%86%E4%BA%AB/result1.png" class="" title="rep;ace"><h2 id="九-打印日志"><a href="#九-打印日志" class="headerlink" title="九. 打印日志"></a>九. 打印日志</h2><p><strong>message(“LIB_DIR:${LIB_DIR}”)</strong></p><h2 id="十-CMAKE-C-XX-FLAGS"><a href="#十-CMAKE-C-XX-FLAGS" class="headerlink" title="十. CMAKE_C(XX)_FLAGS"></a>十. CMAKE_C(XX)_FLAGS</h2><p>​变量 CMAKE_C_FLAGS 存放的内容会被传给 C 编译器，作用在所有的编译组态上。</p><p>​如果希望只针对特定一种组态有效，可以设定 CMAKE_C_FLAGS_&lt;编译组态&gt;，例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">CMAKE_C_FLAGS_RELEASE、CMAKE_C_FLAGS_DEBUG。<br><span class="hljs-keyword">set</span>(CMAKE_C_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_C_FLAGS&#125;     -Wall -O3 -march=native -Wno-reorder&quot;</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -O3 -march=native -Wno-reorder&quot;</span>)<br></code></pre></td></tr></table></figure><p>​设置编译选项为-Wall O3的优化</p><p>其他内部变量：</p><p>· <strong>CMAKE_C_COMPILER</strong>：指定C编译器</p><p>· <strong>CMAKE_CXX_COMPILER</strong>：指定C++编译器</p><p>· <strong>CMAKE_C_FLAGS</strong>：编译C文件时的选项，如-g；也可以通过add_definitions添加编译选项</p><p>· <strong>EXECUTABLE_OUTPUT_PATH</strong>：可执行文件的存放路径</p><p>· <strong>LIBRARY_OUTPUT_PATH</strong>：库文件路径</p><p>· <strong>CMAKE_BUILD_TYPE</strong>：build 类型(Debug, Release, …)，</p><p>· <strong>CMAKE_BUILD_TYPE</strong>&#x3D;Debug</p><p>· <strong>BUILD_SHARED_LIBS</strong>：Switch between shared and static libraries</p><p>内置变量的使用：</p><p>· 在CMakeLists.txt中指定，使用set</p><p>· cmake命令中使用，如cmake -DBUILD_SHARED_LIBS&#x3D;OFF</p><h2 id="十一-target-link-libraries"><a href="#十一-target-link-libraries" class="headerlink" title="十一. target_link_libraries"></a>十一. target_link_libraries</h2><p>​该指令的作用为将目标文件与库文件进行链接。该指令的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(&lt;<span class="hljs-keyword">target</span>&gt; [item1] [item2] [...]<br>                  [[debug|optimized|general] &lt;item&gt;] ...)<br></code></pre></td></tr></table></figure><p>​上述指令中的&lt;target&gt;是指通过add_executable()和add_library()指令生成已经创建的目标文件。而[item]表示库文件没有后缀的名字。</p><p>​默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。</p><p>​这个传递的接口存储在interface_link_libraries的目标属性中，可以通过设置该属性直接重写传递接口。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Cmake</tag>
      
      <tag>网络文章收集</tag>
      
      <tag>学习文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说自己</title>
    <link href="/2022/06/20/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1/"/>
    <url>/2022/06/20/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p>终于又把博客捡起来写了…</p><img src="/2022/06/20/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1/test.png" class="" title="来点图片1"><img src="/2022/06/20/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1/test2.png" class="" title="来点图片2"><img src="/2022/06/20/%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1/test3.png" class="" title="来点图片3">]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/20/hello-world/"/>
    <url>/2022/06/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
